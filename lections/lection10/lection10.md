# Лекция 10. Промисы и асинхронные функции

[Назад](../../README.md)

> Начало данной лекции (про Call Stack, Task Queue и Event Loop повторяет предыдущую лекцию. Для сокращения материала, эта часть в конспекте пропущена.

# Способы организации асинхронного кода

## Функции обратного вызова (callbacks)

Мы можем оборачивать код в функцию-колбек и передавать его куда нам нужно. Например, мы можем вешать колбеки на некоторые события DOM (например, на клик кнопки). Таким образом когда произойдёт клик по кнопке, браузер добавит нашу функцию-колбек в очередь задач, откуда она попадёт в стек вызовов, когда он освободится.

Минус такого подхода заключается в том, что мы не можем отследить данный колбек: выполнился он или нет, что вернул и т.д.

## Промисы

Промис это специальный объект, который представляет _будущий_ результат выполнения операции, которую мы ему передаём. Он никак не влияет на выполнение самой операции и не может нам подсказать когда именно она будет выполнена. Но, мы можем предоставить ему функции, которые он выполнит _после_ того, как асинхронна функция внутри него будет выполнена. Так же, через промис мы можем обработать и вариант событий когда мы получаем какой-то результат из асинхронной функции, и вариант событий, когда внутри асинхронной функции происходит ошибка (например, не получилось получить данные от сервера).

Промис может делать одну вещь - менять своё состояние. Как только мы создаём промис, его состояние устанавливается как `pending`. После этого промис может _только один раз_ поменять своё состояние на одно из двух - либо `fulfilled`, либо `rejected`. Мы _никак_ не можем из своего кода узнать в каком состоянии находится промис. Мы лишь можем навесить на промис колбеки, которые будут вызваны исходя из одного из состояний промиса.

### Синтаксис

Пример создания промиса:

```jsx
const promise1 = new Promise((resolve, reject) => {
  setTimeout(() => {
    resolve("foo");
  }, 300);
});

promise1.then((value) => {
  console.log(value);
  // "foo"
});

const promise2 = new Promise((resolve, reject) => {
  setTimeout(() => {
    reject(Error("Test error"));
  }, 300);
});

promise2.catch((err) => console.log(err.message));
// Uncaught (in promise) Error: Test error
```

В этом примере мы создаём промис, который будет выполнен через 300 мс и вернёт строку `"foo"`. В промис мы передаём колбек, который получает в качестве аргументов колбек `resolve`, который нам нужно вызывать, чтобы "выполнить" промис и колбек `reject`, который нам нужно вызвать, если в промисе что-то пошло не так. В это колбеки можно передавать значения, которые и будут результатом выполнения асинхронной функции. Так же у промисов есть методы `.then` и `.catch`. Данные методы позволяют нам навешивать на промис дополнительные обработчики. Соответственно, `.then` будет выполнен если промис станет `fulfilled`, а `.catch` будет выполнен если промис станет `rejected`. Первым же аргументом эти методы получат значение, которое будет возвращено из асинхронной функции внутри промиса. Мы можем навешивать на промис бесконечное количество обработчиков `.then` и `.catch`, т.к. он меняет своё состояние только один раз и остаётся в нём до конца работы программы.

## Async/await

Так же нам доступны специальные операторы `async` и `await`.

### Async

Мы можем поставить оператор `async` перед любой функцией чтобы сделать её асинхронной. Это значит, что теперь данная функция возвращает промис, в который будет обёрнуто её содержимое.

```jsx
async function myAsyncFunc() {
  return 42;
}
myAsyncFunc().then((value) => console.log(value)); // 42

async function myAsyncFunc2() {
  throw "oops";
}
myAsyncFunc2().catch((err) => console.log(err)); // "oops"
```

## Await

Для удобства создадим функцию-помощника:

```jsx
function wait(ms) {
  return new Promise((r) => setTimeout(r, ms));
}
```

Данная функция возвращает промис, который будет зарезолвлен через `ms` секунд.

Мы можем использовать ключевое слово `await` внутри `async` функции для того, чтобы подождать какой-то асинхронный код. Например:

```jsx
async function myWaitingFunc() {
  await wait(3000);
  return "done";
}
```

В таком случае `return` будет возвращён только _после того_ как будет выполнена строка `await wait(3000);`.

## Promise.all()

Если нам нужно дождаться выполнения нескольких промисов сразу, мы можем использовать `Promise.all()`. Мы просто передаём в него массив промисов, а его результатом будет массив результатов всех этих промисов, то есть `Promise.all([promise, promise, ...]).then([result, result, ...] => {})`.

Тут есть нюанс про последовательное\параллельное выполнение.

Если мы будем использовать `await` для нескольких операций, они будут выполнены последовательно.

```jsx
async function myWaitingFunc() {
  await wait(3000);
  await wait(2000);
  await wait(1000);
  return "done";
}
```

А если же мы хотим, чтобы всё это было выполнено параллельно, то можем использовать `Promise.all()`.

```jsx
async function myWaitingFunc() {
  await Promise.all([wait(3000), wait(2000), wait(1000)]);
  return "done";
}
```
