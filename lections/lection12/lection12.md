# Лекция 12. Введение

[Назад](../../README.md)

# Структура лекции

- Модуль "Фреймворк": о чём, зачем и как?
- История фреймворков
- Бизнес и его задачи
- Домашнее задание

# Цель

Написание своего собственного фреймворка в процессе **разработки** и **последовательного улучшения** реального приложения.

# Зачем?

- создать свой, единственный и неповторимый фреймворк
- дать опыт реального приложения на примере
- улучшить понимание архитектуры и принципов языка программирования, инструментов, уже существующих фреймворков
- for fun and profit!

# Расписание занятий

- 10.04 - Вводная лекция
- 17.04 - Основа приложения (v1.0)
- 24.04 - Сетевые запросы, их виды (v1.1)
- 15.05 - Масштабирование и поддержка большого приложения (v1.2)
- 22.05 - Событийная модель приложения, его состояние (v1.3)
- 29.05 - Виды состояний приложения, потоки данных (v1.4)
- 05.06 - Выход за рамки. Применение полученных знаний в реальном мире (v1.5)

# Условия к выпуску после модуля

Иметь **написанное в ходе курса** и **работающее** приложение в своём репозитории.

# История

Всё началось ещё во время ES5+. Тогда была сформулирована неявная задача:

> Нужно обрабатывать кучу событий от пользователя браузера, общаться с несколькими серверами одновременно, делать сложные и красивые анимации, следить за состоянием всего на странице и не только (воркеры давайте выдумаем ещё!), реализовывать бизнес-логику, микрофронтенды воплощать, рендерить изоморфные приложения на клиенте и на сервере.
> И всё это разрабатывать максимально быстро и дёшево, пожалуйста! ;)

# Design patterns / Паттерны проектирования

Люди писали код и заметили, что некоторые его части работают очень хорошо и повторяются из-за этого. Решили называть эти практики общими словами, чтобы было удобнее общаться, но стандартизации никакой не было. Просто использование похожих практик имело проблемы. В качестве решения этих проблем были предложены фреймворки.

Так же бизнесу нужно было при нанятии новых сотрудников нужно было тратить ресурсы на них для обучения, что не есть хорошо.

# Решения

- Tons of JQuery plugins (всё было в общем неймспейсе и конфликтовало)
- Dojo, Kendo UI (огромные библиотеки)
- GWT (компилим Джаву в JS)
- CanJS
- Backbone.JS (+Marionette/Chaplin), Ractive
- AngularJS (Angular v1.x)
- Knockout.js
- Ember.js
- React.js, Preact, InfernoJS, tons of clones
- Riot.js
- Angular
- Aurelia
- Polymer & Custom Components
- Vue.js
- Dart, Elm, Elixir
- ....

## Офтоп про эти названия

Есть игра, в которой нужно писать слова на английском, если есть такое слово в npm, нужно выпить.

[The NPM drinking game](https://npmdrinkinggame.party/)

# Talk is CHEAP, show me the CODE

[TodoMVC](https://todomvc.com/)

Это одно и то же приложение написанное на разных фреймворках. Можно посмотреть как работают и выглядят фреймворки.

# Бизнес и его задачи

Основная цель бизнеса это менять мир, делать жизнь лучше и зарабатывать деньги.

Основные фреймворки в данный момент на слуху - Vue, React, Angular. Все они выполняют одну задачу - есть одна гора, и к ней есть 3 пути.

# Кто за ними стоит?

- React - Facebook
- Angular - Google
- Vue.js - Netlify, Netguru, Baidu, Livestorm...

# Маркетинг и пиар решает...

... **чуть** больше, чем качество кода или идеи. Какие бы крутые не были идеи и кодовая база - если о них никто не узнает, никто не будет этим пользоваться.

# Зачем всем нужны фреймворки?

Для компании: plug-n-play принцип для разработчиков

Для сотрудников: знакомство с принципами/синтаксисом, удобство

Для нас с вами: снижается порог входа (МОЖНО НАПИСАТЬ СВОЙ ФРЕЙМВОРК)

# Домашнее задание

1. Выбрать тематику приложения, для которого есть (уже написано) API.
2. Написать требования к приложению в виде списка фич, реализуемых вами за вменяемую единицу времени (помните пункт про последовательное улучшение a.k.a. переписывание своего приложения?
3. Создать репозиторий с файлом readme.md на github.com, куда выложить требования списком, в порядке убывания важности.

> Нельзя брать идею приложения для прогноза погоды!
